###################################################################

## Vidéo 1 (fonction génératrice)

CO12AL-W4-VIDEO01.txt

## Compléments Vidéo 1

*parler des expressions génératrice et de leur intérêt (faible occupation
mémoire)
(x**6 + 3*x for x in xrange(100000000))

*redonner le lien vers http://python-history.blogspot.fr/2010/06/from-list-comprehensions-to-generator.html 
déjà cité en W3, VIDEO8
*faire un test de performance avec timeit pour montrer que les 
expressions génératrices sont un peu plus lente que les compréhensions


## Quizz Vidéo 1

## Exercices Vidéo 1


###################################################################

## Vidéo 2 (espaces de nommage)

CO12AL-W4-VIDEO02.txt

## Compléments Vidéo 2

*introduire __dict__, globals(), locals() et dir(mod) dans le contexte
des modules uniquement. (on parlera de __dict__ pour les classes
et les instance plus tard, mais tu peux déjà y faire allusion)

*introduire sys.modules

*parler de l'impossibilité de faire __dict__ du module courant
(en particulier du prompt interactif) et expliquer que l'on 
ne peut y accéder que depuis sys.modules[__name__].__dict__
Citer 
http://docs.python.org/2.6/tutorial/classes.html#id2
et
http://stackoverflow.com/questions/4877290/what-is-the-dict-dict-attribute-of-a-python-class

## Quizz Vidéo 2

## Exercices Vidéo 2


###################################################################

## Vidéo 3 (importatation des modules : compilation et chemin de recherche)

CO12AL-W4-VIDEO03.txt

## Compléments Vidéo 3

*exécuter un module comme un script avec 
if __name__ == '__main__':

*parler de sys.builtin_module_names et de, par exemple, math 
et sys, qui sont des modules built-in implémentés en C pour
des questions de vitesse. 

*compléter la discussion de la video sur les .pyc. Par exemple,
on peut directement distribuer les .pyc sans les .py

*parler de reload() et du problème classique de modifier un module,
l'importer de nouveau et ne pas voir les modifications. 

## Quizz Vidéo 3

## Exercices Vidéo 3

###################################################################

## Vidéo 4 (importation des modules : import et from )

CO12AL-W4-VIDEO04.txt

## Compléments Vidéo 4

*introduire 
import modulename as name
et
from modulename import attrname as name

*introduire 
from mod import *
en expliquant qu'il ne faut jamais le faire avec des modules
que l'on n'a pas écrit nous même parce qu'il y a un fort risque
de collision des espaces de nommage
Citer https://docs.python.org/2.7/reference/simple_stmts.html#the-import-statement
Introduire aussi les variables commençant par _ en expliquant que 
l'on ne doit pas les modifier et qu'elles ne sont pas importée par 
un import *

## Quizz Vidéo 4

## Exercices Vidéo 4

###################################################################

## Vidéo 5 (Programmation objet, concepts de base)

CO12AL-W4-VIDEO05.txt

## Compléments Vidéo 5

## Quizz Vidéo 5

## Exercices Vidéo 5

###################################################################

## Vidéo 6 (Programmation objet: classes, instances et méthodes)

CO12AL-W4-VIDEO06.txt

## Compléments Vidéo 6

* introduire getattr() et setattr()
* introduire la notion de variables privées _var
(privée et pas d'import par from mod import *), __var__ 

## Quizz Vidéo 6

## Exercices Vidéo 6

###################################################################

## Vidéo 7 (Programmation objet: héritage)

CO12AL-W4-VIDEO07.txt

## Compléments Vidéo 7

*introduire la MRO (Method Resolution Order)
http://python-history.blogspot.fr/2010/06/method-resolution-order.html
(attention cet article parle aussi des nouvelles classes)

*expliquer que seules les classes built-in ne sont pas mutables
parce que sinon ça pourrait rendre l'interpréteur instable. 

*citer (et peut-être discuter en montrer des exemples) 
design patterns et le livre de Gramma et al.

* introduire les variables __var (name mangling)
http://docs.python.org/2/reference/lexical_analysis.html#reserved-classes-of-identifiers

## Quizz Vidéo 7

## Exercices Vidéo 7

###################################################################

## Vidéo 8 (Programmation objet: surcharge d'opérateurs)

## Compléments Vidéo 8

*Citer ce lien pour toutes les surcharges d'opérateurs. 
http://docs.python.org/2/reference/datamodel.html#special-method-names
*couvrir d'autres opérateurs (je couvre __init__ et __str__ en vidéo)
Il faut voir au minimum __add__, __contains__, __len__, 
* rappeler que le __iter__ est également une surcharge
* parler des fallback 
Itération : __iter__ puis __getitem__
in :  __contains__ puis __iter__ puis __getitem__
Test vrai/faux : __nonzero__ puis __len__ (faux si __len__ retourne 0)
print : __str__ puis __repr__

*parler des optimisation de CPython sur les opérateurs
Plus rapide d'utiliser un opérateur que l'appel direct sur le méthode
>>> timeit.timeit(setup = "L = range(1000)", number = 100000000, stmt = "0 in L")
3.1706046182752914
>>> timeit.timeit(setup = "L = range(1000)", number = 100000000, stmt = "L.__contains__(0)")
11.681099249275206

## Quizz Vidéo 8

## Exercices Vidéo 8


###################################################################

## Vidéo 9 (Scopes et espaces de nommage)

## Compléments Vidéo 9
citer: 
http://www.python.org/dev/peps/pep-0227/
http://docs.python.org/2.7/reference/executionmodel.html 
http://docs.python.org/2.7/tutorial/classes.html#python-scopes-and-namespaces 

*expliquer ce cas
class A:
    a = 42
    b = list(a + i for i in range(10))
>>>
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    class A:
  File "<pyshell#1>", line 3, in A
    b = list(a + i for i in range(10))
  File "<pyshell#1>", line 3, in <genexpr>
    b = list(a + i for i in range(10))
NameError: global name 'a' is not defined

*faire un notebook sur les règles pour ne pas tomber dans les
cas dangereux:
   -ne jamais utiliser comme nom de variable locale
   un nom qui existe en global
   -toujours mettre la directive global avec l'utilisation
   de la variable.
puis montrer quelques exemples d'erreurs quand on ne suit
pas ses règles
1) binding static au scope local pour les fonction uniquement
(optimisation de CPython) et la fameuse UnboundLocalError
var = 0
def func():
    print var
    var = 1
>>> func()

Traceback (most recent call last):
  File "<pyshell#102>", line 1, in <module>
    func()
  File "C:/Users/alegout/Desktop/test2.py", line 25, in func
    print var
UnboundLocalError: local variable 'var' referenced before assignment

x = "x dans module"
def f():
    if False:
        x = "x dans f()"
    print x
f()
>>> 
Traceback (most recent call last):
  File "C:/Users/alegout/Desktop/temp.py", line 6, in <module>
    f()
  File "C:/Users/alegout/Desktop/temp.py", line 5, in f
    print x
UnboundLocalError: local variable 'x' referenced before assignment

2) le bug http://bugs.python.org/issue532860

3) directive global apres l'utilisation de la variable

## Quizz Vidéo 9

## Exercices Vidéo 9

proposer quelques exercices un peu vicieux (avec des imports, des classes, des fonctions
englobantes, etc.)

###################################################################

## Vidéo 10 (Itérateurs côté concepteurs)

## Compléments Vidéo 10

## Quizz Vidéo 10

## Exercices Vidéo 10

Donnes des exos pratiques de création d'objets avec des itérateurs

###################################################################

## Vidéo 11 (exceptions)

## Compléments Vidéo 11

*parler des Warning et du module warning
https://docs.python.org/2.7/library/warnings.html#module-warnings

*donner la référence de la documentation de toutes les 
exceptions built-in https://docs.python.org/2.7/library/exceptions.html#bltin-exceptions


## Quizz Vidéo 11

## Exercices Vidéo 11

###################################################################

## Vidéo 12 ()

## Compléments Vidéo 12

## Quizz Vidéo 12

## Exercices Vidéo 12