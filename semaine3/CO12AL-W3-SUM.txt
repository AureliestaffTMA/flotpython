###################################################################

## Vidéo 1 (101 des modules)

CO12AL-W3-VIDEO01.txt
# import - dir - help

## Compléments Vidéo 1

-ajouter un lien vers la Python Standard Library
https://docs.python.org/2/library/index.html

## Quizz Vidéo 1

## Exercices Vidéo 1


###################################################################

## Vidéo 2 (indentation comme syntaxe de base)

CO12AL-W3-VIDEO02.txt
# indentation - syntaxe minimale - presentation unifiee - 79 cars

## Compléments Vidéo 2

-ajouter un lien vers la PEP 008 (sur les conventions de codage)
http://legacy.python.org/dev/peps/pep-0008/
-ajouter un lien vers cette FAQ https://docs.python.org/2/faq/design.html#why-are-colons-required-for-the-if-while-def-class-statements

## Quizz Vidéo 2

## Exercices Vidéo 2


###################################################################

## Vidéo 3 (if elif else + and/or/not)
# if avec resultat non booleen
# operateurs booleens - priorites..

CO12AL-W3-VIDEO03.txt

## Compléments Vidéo 3

## Quizz Vidéo 3

## Exercices Vidéo 3

-opérateurs de tests booléens and, or, not (vu en cours, montrer
d'autres exemples)
-opération shortcircuit and et or (vu en cours, montrer d'autres exemples)
-discuter de == : quand peut-on comparer des objets de types différents
(seulement les numériques, et les set et frozenset, str/unicode, mais
(1, 2) n'est pas égal à [1, 2])
-quel sens à des comparaisons (avec < ou >) de listes ou dicts. 


###################################################################

## Vidéo 4 (boucle for et itérateurs)

CO12AL-W3-VIDEO04.txt
# for sur une sequence - for sur un objet qui a un iterateur -
# __iter__  / next / StopIteration

## Compléments Vidéo 4

-présenter break
-présenter continue (en expliquant que, comme pour les goto, les sauts
dans le code nuisent à la compréhension, il faut donc l'éviter)
-présenter pass qui est utilisé pour rendre syntaxiquement correct un bloc
de code que l'on n'a pas encore écrit (voir pour les fonctions, for, if)
-voir le else du for
-présenter enumerate, zip, et les itérateurs des dictionnaires
-présenter xrange() et sont avantage par rapport à range() (pas 
d'occupation mémoire). Dans le même esprit expliquer l'avantage
des itérateurs sur des dict (iteritems/itervalues/iterkeys) par rapport
aux listes. 
-présenter la méthode built-in iter() en expliquant que comme
__iter__() est une méthode Python privée, on ne doit pas l'appeler
directement dans un programme, on doit utiliser la built-in iter()
à la place.

# xxx ceci n'est définitivement pas un exo..
Il ne faut pas modifier l'objet sur lequel on itère dans boucle for.
Si on modifie l'objet, il faut itérer sur copie
>>> L = ['a', 'b' , 'c']
>>> for i in L[:]:
	if i == 'c':
		L.append(i)	

Ici, sinon on a une boucle infinie.

## Quizz Vidéo 4

## Exercices Vidéo 4


###################################################################

## Vidéo 5 (files)
# open('w') - close - write - "\n

CO12AL-W3-VIDEO05.txt

## Compléments Vidéo 5

*donner le lien vers https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files
*exemple de flush()
*voire read, tell, seek, writelines
*introduire json et pickle
*inroduire le mode b pour ouvrir des fichiers binaires et les autres
modes utilise (e.g., a, r+)
*expliquer pourquoi le fichier est un itérateur et n'a pas des itérateurs
comme les autres types built-in (c'est lié à la manières des OS de gérer
les accès aux fichiers). 
*introduire sys.stdout (comparer avec print), sys.stdin (comparer 
sys.stdin.readline() avec raw_input), et sys.stderr
*montrer que sys.stdout n'est q'une variable qui peut référencer un 
autre fichier. Comme print écrit dans sys.stdout, c'est un moyen simple
de rediriger les print vers un fichier. 
*en complément introduire le module logging (ça va bien ici, mais
si ça fait trop de compléments, on peut le bouger en semaine 6 ou 7)
avec les références https://docs.python.org/2/library/logging.html
et https://docs.python.org/2/howto/logging.html#logging-basic-tutorial



## Quizz Vidéo 5

## Exercices Vidéo 5


###################################################################

## Vidéo 6 (while)

CO12AL-W3-VIDEO06.txt

## Compléments Vidéo 6
-voir le break et le continue (déjà vu pour for, mais
à revoir dans le contexte du while)
-voir le else du while


## Quizz Vidéo 6

## Exercices Vidéo 6

x='spam'
while x:
    print x
    x = x[1:]




###################################################################

## Vidéo 7 (fonction lambda, map, filter)

CO12AL-W3-VIDEO07.txt

## Compléments Vidéo 7

*voir reduce 
*voir exec et eval. Ça n'est pas en lien direct, mais il faut
le voir et il y a peu de compléments pour cette vidéo alors
autant le placer ici. 

## Quizz Vidéo 7

## Exercices Vidéo 7

*faire de beaux exemples pratiques d'application de map et filter


###################################################################

## Vidéo 8 (compréhension listes, set, dictionnaires)

CO12AL-W3-VIDEO08.txt

## Compléments Vidéo 8

*Comparer la performance des boucles for, de map, de la compréhension. 
S'inspirer de :
http://www-sop.inria.fr/members/Arnaud.Legout/EDU/Python/performanceFonctions2.py

*Donner le lien vers http://python-history.blogspot.fr/2010/06/from-list-comprehensions-to-generator.html 
pour une discussion intéressante sur la compréhension, les expression
génératrice et Python 2 et 3.

*montrer le cas d'une compréhension sur plusieurs variables et montrer
comment lire cette expression, par exemple, 
[(x,y) for x in range(5) if x % 2 == 0 
	     for y in range(5) if y % 2 == 1]


L = []
for x in range(5):
    if x % 2 == 0:
        for y in range(5):
            if y % 2 == 1:
                L.append((x,y))


Expliquer que la compréhension sur plusieurs variables est difficile
à lire et que c'est par conséquent une mauvaise idée en général.

## Quizz Vidéo 8

## Exercices Vidéo 8


###################################################################

## Vidéo 9 (fonctions : objet, passage d'arguments par ref, return, polymorphisme)

CO12AL-W3-VIDEO09.txt

## Compléments Vidéo 9

* cas pratique de plusieurs return 
* effet de bord du passage par ref de mutable (illustration de la video)
* expliquer comment ne pas modifier un mutable passé en argument:
reprendre l'exemple de la video

L = []
def h(a):
	a.append(1)

Comment ne pas modifier L. Trois possibilité:
-à l'appel h(L[:]) on passe une shallow copy, ça permet
de choisir la modification par effect de bord à l'appel
(peut-être utile lorsque la fonction fait autre chose avec L)
-à l'appel si on veut une exception en cas de tentative
de modification (utile pour les librairies) h(tuple(L))
-dans h en ajoutant a = a[:] avant le append pour garantir
que h ne modifiera jamais L. 
-parler de la documentation automatique sur les fonctions 
et de l'argument __doc__ utilisé par help()
def func(a, b, c, d):
    """
    Cette fonction imprime 4 parametres a la suite
    """
    print a, b, c, d
	
>>>print func.__doc__
 Cette fonction imprime 4 parametres a la suite
>>>help(func)
Help on function func in module __main__:

func(a, b, c, d)
    Cette fonction imprime 4 parametres a la suite


## Quizz Vidéo 9

## Exercices Vidéo 9


###################################################################

## Vidéo 10 (fonctions : scope des variables, regle LEG)

CO12AL-W3-VIDEO010.txt

## Compléments Vidéo 10

-parler du scope built-in et montrer le module built-in. 
-expliquer que les variables dans l'entête des fonctions sont
aussi des variables locales. 
-montrer que l'on peut redéfinir un nom built-in et que c'est
une mauvaise idée. 
-rappeler qu'il faut utiliser des bons noms de variables et qu'il
faut éviter d'utiliser localement un nom de variable globales
(ça peut conduire à des erreurs ou a des comportement étranges
que j'expliquerai plus tard dans les vidéos). 
-montrer est expliquer l'erreur UnboundLocalError
var = 0
def func():
    print var

def func2():
    print var
    var = 1

func()
func2()
>>> 
0

Traceback (most recent call last):
  File "C:/Users/alegout/Desktop/test.py", line 12, in <module>
    func2()
  File "C:/Users/alegout/Desktop/test.py", line 8, in func2
    print var
UnboundLocalError: local variable 'var' referenced before assignment

## Quizz Vidéo 10

## Exercices Vidéo 10

-nombreux exemple de scope avec fonctions englobantes. 

###################################################################

## Vidéo 11 (fonctions : scope global)

CO12AL-W3-VIDEO011.txt

## Compléments Vidéo 11

*montrer que global crée une variable global si elle n'existe
pas encore. 
x = 1
def f():
    global y
	y = x + 1
print y # n'existe pas encore
f()
print y # existe dans le scope global. 

*revenir sur les bonnes pratiques de programmation avec global (en 
limitant son usage et en favorisant les retours explicite de fonction). 

## Quizz Vidéo 11

## Exercices Vidéo 11


###################################################################

## Vidéo 12 (fonctions : passage d'arguments)

CO12AL-W3-VIDEO012.txt

## Compléments Vidéo 12

*introduire sys.argv en remarquant que c'est une forme *Targs
et introduire le module argparse. 
*donner des exemples pratiques de forme * et ** (si tu en as)
*montrer un exemple de mélange des 4 déclarations d'arguments
def f(a, c = 3, *d, **e)
*montrer l'erreur qu'il peut se produire lorsque l'on combine
des formes positionnelles et des formes nommés lors de l'appel.
def func(a, b, c, d):
    print a, b, c, d
func(1, c = 3, *(2,), **{'d':4})
>>>
1 2 3 4
>>> func(1, b = 3, *(2,), **{'d':4})
Traceback (most recent call last):
  File "<pyshell#170>", line 1, in <module>
    func(1, b = 3, *(2,), **{'d':4})
TypeError: func() got multiple values for keyword argument 'b'

Expliquer que les arguments ne sont pas pris dans l'ordre 
de l'appel, mais les arguments positionnel sont utilisé en premier. 
les arguments ordonnés et *args, ne donnent pas le nom des arguments, donc ils ne peut être que positionnel. Par contre, les arguments nommés et **args fournissent le nom. Ils sont donc traités en dernier. 
C'est expliqué dans Dans Python Language Reference: 5.3.4. Calls
https://docs.python.org/2/reference/expressions.html#calls

*montrer le piège des arguments par défaut qui ne sont initialisé
qu'une fois à la création de l'objet fonction, donc problème avec 
les mutables
https://docs.python.org/2/tutorial/controlflow.html#default-argument-values
def f(a, L = []):
    L.append(a)
    print L
f(1)
f(2)
f(3)
>>>
[1]
[1, 2]
[1, 2, 3]

Solutions
def f(a, L = None):
    if L is None:
        L = []
    L.append(a)
    print L
f(1)
f(2)
f(3)
>>>
[1]
[2]
[3]




## Quizz Vidéo 12

## Exercices Vidéo 12


###################################################################
