<hr/>
Noms de variables
=====

Parmi les noms de variables suivants, lesquels sont autorisés par le langage (avec les choix multiples présentés comme ici avec des cases carrées, vous devez choisir toutes les réponses valides; il peut y en avoir zéro, une, ou plusieurs)

[x] nom_de_variable
[ ] nom-de-variable
[x] nom_de_variable2
[ ] nom:de:variable
[x] NomDeVariable
[ ] 2eme_variable
[x] _nom_de_variable

[explanation]
Seules les réponses d'indice impair sont correctes.

le caractère deux-points ':' n'est pas autorisé

le caractère '-' n'est pas autorisé

un identifiant ne peut pas commencer par un chiffre
[explanation]


<hr/>
Accents dans les noms de variables
=====

On peut utiliser des caractères accentués dans les noms de variables (vous pouvez remarquer ici que les cases à cocher sont rondes; dans ces questions-là il y a exactement une bonne réponse)

( ) Oui
(x) Non

[explanation]
On ne peut utiliser des accents que dans les commentaires, et à l'intérieur des chaînes de caractères.
[explanation]

<hr/>
Tirets dans les noms de variables
=====

Parmi les noms de variables suivants, lesquels sont autorisés par le langage

[x] _
[x] _A
[x] _a_
[x] A_
[x] __

[explanation]
Toutes ces formes sont légales, y compris la première malgré l'absence de caractère alphanumérique

On notera toutefois qu'elles sont toutes non recommandées

[explanation]
<hr/>
Types numériques (1)
=====

Comment calculer la 16-ème puissance de 2

( ) 2 &amp; 16
(x) 2 ** 16
( ) 2 &amp;&amp; 16
( ) 2 | 16

[explanation]
Le signe puissance en python est **
[explanation]

<hr/>
Types numériques (2)
=====

Comment entrer la valeur du complexe 3 + 2i

( ) 3 + 2i
(x) 3 + 2j
( ) 3 + 2 * i
( ) 3 + 2 * j

[explanation]
Les anglais utilisent 'j' plutôt que notre 'i'
Les deux dernières formes font référence à une variable "normale" qui s'appellerait 'i' ou 'j'
[explanation]

<hr/>
Types numériques (3)
=====

Que retourne la formule

<pre>type(2 ** 16) == type(2 ** 8)</pre>

(x) True
( ) False

[explanation]
Ces deux puissances de 2 sont toutes deux assez petites pour être représentées par des entiers simples
[explanation]

<hr/>
Types numériques (4)
=====

Que retourne la formule

<pre>type(2 ** 200) == type(2 ** 8)</pre>

( ) True
(x) False

[explanation]
Par contre ici 2 ** 200 est beaucoup trop gros pour être représenté par un entier simple, c'est un entier long.
[explanation]

<hr/>
Types numériques (5)
=====

Que retourne la formule (avancé)

<pre>(2 ** 200) >> 196 == 2 ** 4</pre>

(x) True
( ) False

[explanation]
On a vu que le décalage vers la droite représente une division entière par 2 ** n

Donc 2 puissance 200, décalé à droite de 196 vaut bien 2 puissance 4

Par ailleurs, la comparaison d'un entier long et d'un entier simple de même valeur retourne - heureusement - True
[explanation]

Opérations sur les séquences
=====

On se donne la variable suivante

<pre>chaine = "douarnenez"</pre>

Trouver la valeur des expressions suivantes

<pre>chaine.index('z') == len(chaine) </pre>

( ) True
(x) False

<pre>chaine.index('z') == len(chaine) - 1</pre>

(x) True
( ) False

<pre>'daz' in chaine</pre>

( ) True
(x) False

<pre>'nez' in chaine </pre>

(x) True
( ) False

<pre>chaine[-3:] == 'nez'</pre>

(x) True
( ) False

<pre>chaine[1:3] + chaine[3:5] + chaine[5:] == chaine[1:]</pre>

(x) True
( ) False
<hr/>
Listes (1)
=====

On a 
<pre>liste = [1, 3, 2, 4]</pre>
On veut modifier liste pour obtenir [1, 3, 5, 2, 4]

Que faut-il faire (plusieurs réponses possibles):

[ ] liste[2] = 5
[ ] liste[2] = [5]
[x] liste.insert(2,5)
[ ] liste[2:3] = [5]
[x] liste[2:2] = [5]

[explanation]
La première formule remplace 2 par 5, la liste conserve 4 éléments
La seconde, idem mais la liste devient &#91;1, 2, &#91;5&#93;, 4&#93;
La troisième est correcte
La quatrième est équivalente à la première, elle remplace 2 par 5
La cinquième est correcte
[explanation]


<hr/>
Listes (2)
=====

À nouveau on a 
<pre>liste = [1, 3, 2, 4]</pre>

On souhaite "extraire" et retourner la valeur '1', tout en la retirant de la liste.
Plus précisément on veut affecter à la variable 'suivant' la valeur '1' de telle sorte qu'après l'exécution, liste ne contienne plus que [3, 2, 4]

Que faut-il faire:

[ ] suivant = liste[0]
[x] suivant = liste.pop(0)
[ ] del liste[0]
[ ] suivant = del liste[0]

[explanation]
La première formule retourne bien '1' mais ne modifie pas la liste
La troisième enlève bien '1' de liste mais ne retourne rien
La dernière formule est syntaxiquement incorrecte
[explanation]


<hr/>
Listes (3)
=====

On a encore
<pre>liste = [1, 3, 2, 4]</pre>

On veut trier la liste en ordre décroissant et en place, c'est-à-dire sans duplication de liste.

Faut-il faire (plusieurs réponses possibles) :

[x] liste.sort(reverse=True)
[ ] liste.sort()
[ ] sorted(liste, reverse=True)
[x] liste.sort(); liste.reverse()

[explanation]
Il faut bien préciser reverse=True pour obtenir un tri décroissant

Il n'est pas nécessaire ici de copier la liste initiale, c'est pourquoi ce n'est pas une bonne idée d'utiliser sorted.

La dernière formule fonctionne très bien également.
[explanation]


<hr/>
Listes (4)
=====

On a toujours
<pre>liste = ['1', '3', '2', '4']</pre>

On veut ajouter à la fin de la liste les valeurs '5' et '6' pour obtenir ['1', '3', '2', '4', '5', '6']

Faut-il faire (plusieurs réponses possibles) :

[x] liste = liste + ['5', '6']
[x] liste.extend(['5', '6'])
[ ] liste.append(['5', '6'])
[x] liste.append('5'); liste.append('6')
[x] liste.extend('56')
[x] liste += ['5', '6'] 

[explanation]
Toutes les formules sauf la 3 sont correctes

La formule 3 donne pour liste &#91; 1, 3, 2, 4, &#91;5, 6&#93; &#93;

Notez que la formule 5 fonctionne, car extend attend un iterable (ici un string) et ajoute tous les éléments de cet iterable; on aurait pu utiliser aussi un tuple par exemple.

[explanation]
<hr/>
Tuples (1)
=====

On se donne en entrée 
<pre>triple = (1,2,3,)</pre>

Parmi les expressions et instructions ci-dessous, lesquelles sont valides

[x] triple[0]
[x] triple[:]
[ ] triple[len(triple)]
[ ] triple[0] = 0

[explanation]
La première expression est correcte et renvoie 1
La seconde expression est correcte et renvoie une copie du tuple
La troisième expression n'est pas valable, "index out of range", triple n'a pas de case numéro 3
L'affection en quatrième place n'est pas autorisée, un tuple est immuable 
[explanation]

<hr/>
Tuples (2)
=====

Quelles sont les expressions qui renvoient True

[x] [ ( [ ('spam') ] ) ] == [ [ 'spam' ] ]
[ ] ('spam',) == ('spam')
[x] [ ('spam',) ] [0][0] == 'spam'
[ ] [ ('spam'), ] [0][0] == 'spam'

[explanation]
Dans la première expression, l'absence de virgule rend les parenthèses vides de sens
Dans la seconde expression la partie droite n'est pas un tuple
Dans la troisième expression, on a une liste contenant un tuple contenant le string, l'expression renvoie True
Dans la quatrième expression, la virgule n'est pas correctement placée et la parenthèse ne crée pas un tuple.
[explanation]

<hr/>
Tuples (3)
=====

On pose
<pre>quadruple = (1, [2, 3], 'spam', [ (4,) ] )</pre>

Quelles sont parmi les affectations suivantes celles qui sont valables, et qui affectent 4 à four

[ ] ( one, (two, three), ignored, ( ( four ) ) ) = quadruple
[x] ( one, (two, three,), _, ( ( four, ), ) ) = quadruple
[ ] ( (one,),  (two, three), _, [ [ four ] ] ) = quadruple
[x] ( one,  (two, three), _, [ [ four ] ] ) = quadruple


[explanation]
Dans la première forme, 'four' ne se trouve pas dans un tuple à cause de l'absence de virgule
La seconde forme est correcte
Dans la troisième forme, 'one' est inclus dans un tuple, ce qui empêche l'affectation de fonctionner
La dernière forme est correcte, malgré la présence d'une liste à gauche et d'un tuple à droite au dernier niveau de profondeur.
[explanation]

<hr/>
Listes
=====

On cherche à écrire un code qui permette d'intervertir les deux derniers éléments dans une liste. On suppose que la liste en entrée a au moins deux éléments. Quelles sont parmi les variantes suivantes celles qui font bien ce qu'on veut

[x] tmp = liste[-1]; liste[-1] = liste [-2]; liste[-2] = tmp
[ ] liste.reverse(-2,-1)
[x] liste[-2],liste[-1] = liste[-1],liste[-2]

[explanation] 
La première formule fonctionne, quoi que pas très "pythonique"
La seconde formule est une invention, list.reverse() n'accepte pas d'argument, comme le montrerait help(reverse)
La dernière formule fonctionne, ce serait notre préférée. Comme on l'a vu déjà, les expressions à gauche de l'affectation sont toutes évaluées, puis l'affectation est réalisée.
[explanation]

<hr/>
Strings (1)
=====

On reçoit en entrée une chaîne dont on sait qu'elle est de taille impaire, et on veut écrire dans la case du milieu un caractère "-", c'est-à-dire que par exemple

<pre>chaine = "a"  => chaine = "-"</pre>
<pre>chaine = "abc"  => chaine = "a-c"</pre>
<pre>chaine = "abcde"  => chaine = "ab-de"</pre>

Comment peut-on faire

[ ] chaine [ len(chaine)/2 ] = "-"
[ ] chaine = chaine [:len(chaine)/2] + "-" + chaine [len(chaine)/2:]
[x] chaine = chaine [:len(chaine)/2] + "-" + chaine [len(chaine)/2+1:]

[explanation]
Le premier choix n'est pas valide car le type chaîne n'est pas mutable

Le second choix n'est pas correct, car le résultat contient un caractère de trop

Le troisième choix est correct

[explanation]

<hr/>
Strings (2)
=====

À partir d'une chaîne, on veut calculer une chaîne dérivée où le caractère '-' est inséré entre les caractères de la chaîne originelle, c'est-à-dire que par exemple

<pre>chaine = ""  => resultat = ""</pre>
<pre>chaine = "a"  => resultat = "a"</pre>
<pre>chaine = "abcd"  => resultat = "a-b-c-d"</pre>

Comment peut-on faire (plusieurs réponses possibles)

[x] "-".join(chaine)
[x] "-".join(list(chaine))

[explanation]
La première clause est correcte, c'est bien sûr le plus simple

La seconde est correcte également, et reste acceptable car elle convertit la chaîne en liste; si on n'est plus très sûr de savoir si "join" se comporte correctement avec une chaîne en argument, au moins comme ceci on est sûr de son coup.

[explanation]

<hr/>
Strings - formatage
=====

Dans du code nouveau on veut mettre en forme un message à partir de 3 variables (nom, no_secu, age) pour obtenir, par exemple

<pre>nom = "Dupont",  no_secu = "1975787", age = "25" 
     => message = "Dupont, 25 ans, 1975787"</pre>

<pre>nom = "Durand",  no_secu = None, age = "12" 
     => message = "Durand, 12 ans, pas de no de SS"</pre>

On envisage plusieurs solutions pour réaliser cela

Solution 1
<pre>
message = "{nom}, {age} ans, {secu}".\
          format(nom=nom, age=age, 
                 secu = no_secu if no_secu else "pas de no de SS")
</pre>

Solution 2
<pre>
message = "{}, {} ans, {}".\
          format(nom, age, no_secu if no_secu else "pas de no de SS")
</pre>

Solution 3
<pre>
message = "%s, %s ans, %s".\
          format(nom, age, no_secu if no_secu else "pas de no de SS")
</pre>

Solution 4
<pre>
message = nom + ", " + age + " ans, " +\
          no_secu if no_secu else "pas de no de SS" 
</pre>

Solution 5
<pre>
message = "%s, %s, %s" % (nom, age, 
                          no_secu if no_secu else "pas de no de SS" )
</pre>

Quelle(s) solution(s) est(sont) correcte(s) ?

[x] 1
[x] 2
[ ] 3
[x] 4
[ ] 5

[explanation]
Les clauses 1, 2 et 4 sont correctes - on voit cependant que la clause 4 est plus difficile à relire et donc à modifier

La clause 3 est erronée, elle mélange les '%s' de l'opérateur % avec la méthode format

La dernière clause, quoique correcte, est à éviter dans du nouveau code.

[explanation]

<hr/>
Dictionnaires (1)
=====

Le type dictionnaire en python est un type

( ) immuable
(x) mutable

[explanation]
On peut ajouter ou enlever des couples (clé, valeur) dans un dictionnaire
[explanation]


<hr/>
Dictionnaires (2)
=====

Dans un dictionnaire, peut-on connaître l'ordre dans lequel les clés ont été insérées ?

( ) oui
(x) non

[explanation]
Nous avons vu l'implémentation des dictionnaires sous forme d'une table de hash.

Comme les clés sont rangées en fonction de la fonction de hachage, l'implémentation de base des dictionnaires ne se souvient pas de l'ordre dans lequel les clés sont insérées.

NB. la classe OrderedDict, dans le module collections, ajoute cette fonctionnalité.
[explanation]

<hr/>
Dictionnaires (3)
=====

Parmi les objets suivants, quels sont ceux qui peuvent être utilisés comme une clé dans un dictionnaire

[x] 1
[ ] [1, 2]
[x] (1, 2)
[ ] ([1, 2], [3, 4])

[explanation]
Les objets 2 et 4 peuvent être modifiés car ils contiennent au moins une liste, ils ne peuvent donc pas servir de clé
[explanation]


<hr/>
Dictionnaires (4)
=====

Pour modifier la valeur de la clé 'marc' dont on sait qu'elle est dans le dictionnaire 'annuaire', on peut faire

[x] annuaire['marc'] = 50
[ ] d.get('marc',50)
[ ] d.setdefault('marc',50)

[explanation]
La seconde forme retourne la valeur pour 'marc' si elle existe, et sinon 50, mais ne modifie pas la valeur.

La troisième forme ne créé la clé 'marc' que si elle n'est pas encore présente
[explanation]

<hr/>
Dictionnaires (5)
=====

Pour accéder à la valeur de la clé 'marc' dont on ne sait pas si elle est dans le dictionnaire 'annuaire', on peut faire

[ ] annuaire['marc']
[x] d.get('marc')
[x] d.get('marc', None)
[ ] get(d, 'marc')
[x] 'marc' in annuaire and annuaire['marc']

[explanation]
La première forme lève une exception si 'marc' n'est pas présent

Les formes 2 et 3 sont exactement équivalentes: on obtient la valeur, ou None si la clé n'est pas présente

La forme 4 est fantaisiste, il n'y a pas de fonction "built-in" get

La dernière forme fonctionne aussi, mais remarquez qu'ici on retourne False - et non pas None - si la clé n'est pas présente
[explanation]
<hr/>
Références partagées (1)
=====

On définit une liste comme étant

<pre>liste = 3 * [0] </pre>

après quoi on fait 

<pre>liste[0] = 1</pre>

qu'obtient-on si on imprime liste à ce stade ?

(x) [1, 0, 0]
( ) [1, 1, 1]

[explanation]
l'affectation de liste&#91;0&#93; ne change pas les deux autres éléments de la liste
[explanation]

<hr/>
Références partagées (2)
=====

À présent on définit une liste 

<pre>liste = 3 * [ [0] ]</pre>

après quoi on fait 

<pre>liste[0][0] = 1</pre>

qu'obtient-on si on imprime liste à ce stade ?

( ) [ [1], [0], [0] ]
(x) [ [1], [1], [1] ]

[explanation]
Cette fois l'affectation concerne la liste à un élément qui est partagée par les trois éléments de liste, on est dans le cas d'une référence partagée, la modification affecte les 3 élément de la liste
[explanation]

<hr/>
Références partagées (3)
=====

Dans l'exercice précédent, comment faire pour éviter que les trois éléments de liste ne soient modifiées ?

[ ] il n'y a rien à faire, la modification ne concerne que le premier élément
[ ] il faut faire une "shallow copy"
[x] il faut faire une "deep copy"

[explanation]
Il faut faire une copie en profondeur car le premier niveau de la liste reste en fait inchangé lors de l'affectation
[explanation]
<hr/>
Itérables
=====

Parmi les types suivants, lesquels sont des itérables ?

[x] list
[x] tuple
[x] dict
[x] set
[ ] float
[x] str
[ ] complex

[explanation]
On peut itérer sur tous les types de base qui constituent une collection d'autres objets (list, tuple, set)
On peut itérer sur les chaînes de caractères, dans ce cas on balaye autant de sous-chaînes que de caractères
On peut itérer sur les dictionnaires, on balaye alors toutes les clés du dictionnaire

On ne peut pas itérer sur les objets atomiques, en particulier float et complex.
[explanation]


Est-ce qu'on peut toujours faire une boucle sur un objet qui a une méthode __iter__() qui renvoie un itérateur ?

(x) Oui
( ) Non

[explanation]
Oui, et dans ce cas la boucle for va utiliser cet iterateur pour implementer son parcours.
[explanation]

Est-ce que si on peut faire une boucle sur un objet alors c'est qu'il propose une méthode next() ?

( ) Oui
(x) Non

[explanation]
La méthode next() est requise sur les itérateurs, pas forcément sur les itérables.
[explanation]

<hr/>
Itérateurs
=====

Parmi les types suivants, lesquels sont des itérateurs ? N'hésitez pas à vous servir d'un interpréteur python en cas de doute:

[ ] list
[ ] tuple
[ ] dict
[ ] set
[ ] float
[ ] str
[ ] complex

[explanation]
float et complex ne sont pas itérables.
str ne possède pas la méthode __iter__(), c'est un itérable implémenté avec la méthode __getitem__()
S'agissant des 4 types restants (list, tuple, dict et set), les itérateurs sont implémentés comme des objets séparés de l'itérable. Cela permet notamment d'autoriser deux boucles imbriquées sur le même objet.
[explanation]
<hr/>
Fonctions (1)
=====

Une fonction en python 

( ) doit contenir une instruction return 
( ) peut contenir 0 ou 1 instruction return
(x) peut contenir 0 on n instructions return

[explanation]
Le return est opionnel, si la fonction retourne sans avoir rencontré return elle retourne 'None'

On peut utiliser autant de return que l'on veut dans une fonction

[explanation]

<hr/>
Fonctions (2)
=====

Est-il possible pour une fonction de modifier l'objet qui lui est passé en argument

(x) Oui, si l'objet est mutable
( ) Oui, on peut modifier tous les objets
( ) Non, une fonction travaille sur une copie et elle ne peut modifier l'objet dans l'espace de l'appelant

[explanation]
Comme les arguments sont passés par référence, les objets de l'appelant, s'ils sont mutables, peuvent être modifiés à l'intérieur de la fonction.
[explanation]
<hr/>
Variable locale à une fonction (1)
=====

Dans quel cas la variable var est locale à la fonction.

Proposition 1
<pre>
var = 'globale'
def f():
    tmp = 'locale'
    return var
</pre>

Proposition 2
<pre>
var = 'globale'
def f():
    var = 'locale'
    return var
</pre>

Proposition 3
<pre>
var = 'globale'
def f():
    print var
    var = 'locale'
    return var
</pre>


Choisissez une ou plusieurs propositions.

[ ] Proposition 1
[x] Proposition 2
[ ] Proposition 3

[explanation]
Dans la proposition 1, la variable var n'est jamais affectée dans la fonction, donc elle n'est pas une variable locale à la fonction, mais une variable globale. 

Dans la proposition 2, la variable var est affectée à la première ligne de la fonction. Elle devient donc locale à la fonction. 

Dans la proposition 3, la variable var est affectée à la deuxième ligne de la fonction, mais après avoir été référencée à la première ligne. Dans ce cas, Python juge qu'il y a une ambiguïté et va lancer une exception particulière qui n'est lancée que dans ce cas précis : UnboundLocalError. Il y a un complément spécifique sur cette erreur qu'il est très important de comprendre. 
[explanation]

<hr/>
Portée (scope) des variables (2)
=====

Que va afficher : print f() ?

<pre>
var = 10
def f():
    var = 20
    def g():
        return var
    return g()
print f()	
</pre>

Choisissez une proposition.

( ) 10
(x) 20
( ) None
( ) Une exception

[explanation]
Suivant la règle LEG, la valeur de var dans g est 20. Comme g retourne la valeur de var et que f retourne la valeur de retour de g, print f() affiche 20. 

Si ce résultat vous semble clair et que vous avez déjà lu l'errata de cette vidéo, vous pouvez passer l'explication suivante, sinon, lisez la attentivement.

Cette semaine, nous considérons deux notions de blocs de code : le bloc de code d'un module et le bloc de code d'une fonction (nous verrons en semaine 5 un nouveau bloc de code, celui des classes). 

Une variable est soit affectée, on lui donne alors une valeur qui est l'objet référencé par la variable, soit référencée, on utilise alors la valeur d'une variable précédemment affectée. Regardons maintenant le lien entre ces notions d'affectation et de référencement avec les notions de bloc de code et de scope.  

Une variable qui est affectée dans un bloc de code devient locale à ce bloc. On dit que la variable est locale à la fonction ou au module et par définition, une variable locale à un module est appelée une variable globale. 

En résumé, une variable affectée dans une fonction est locale à la fonction. La valeur de cette variable sera accessible à toutes les instructions dans le bloc de code de cette fonction et à toutes les instructions dans les blocs de code des fonctions définies dans cette fonction. Une variable affectée dans  un module (en dehors d'une fonction) est une variable globale du module. La valeur de cette variable sera accessible à toutes les instructions dans le module, y compris aux instructions dans les blocs de code des fonctions du module. 

On appelle l'accessibilité de la valeur d'une variable le scope (ou la portée) de cette variable. 

Lorsque l'on référence une variable, on va chercher sa valeur suivant la règle LEG. On cherche la variable localement au bloc de code dans lequel elle est référencée, puis, si elle n'est pas définie, dans le bloc de code des fonctions englobantes, puis, si elle n'est toujours pas définie,  dans le bloc de code du module. De manière équivalente, on pourrait dire que la valeur de la variable référencée est celle de la variable locale du même bloc de code, puis de la variable locale des fonctions englobantes, puis de la variable globale. 
[explanation]
<hr/>
Variables et objets (1)
=====

Dans quel cas la fonction modifie en place l'objet référencé par la variable var ?

Proposition 1
<pre>
var = [1, 2]
def f():
    var = 20
f()
</pre> 

Proposition 2
<pre>
var = [1, 2]
def f():
    var = [1, 3]
f()
</pre> 

Proposition 3
<pre>
var = [1, 2]
def f():
    var.append(3)
f()
</pre> 

Proposition 4
<pre>
var = [1, 2]
def f():
    global var
    var = 1
f()
</pre> 

Proposition 5
<pre>
var = [1, 2]
def f():
    global var
    var.append(10)
f()
</pre> 

Choisissez une ou plusieurs propositions.

[ ] Proposition 1
[ ] Proposition 2
[x] Proposition 3
[ ] Proposition 4
[x] Proposition 5

[explanation]
Ce quiz joue avec les notions de modification d'objets et de références. Une variable référence un objet et l'opération d'affectation permet de changer l'objet référencé par une variable. Par contre, sans changer l'objet référencé par une variable, on peut modifier un objet mutable par effet de bord. Regardons maintenant les différentes propositions. 

La fonction dans la proposition 1 ne modifie pas l'objet puisque la fonction crée une variable locale var distincte de la variable globale var. 

La fonction dans la proposition 2 ne modifie pas non plus l'objet puisqu'ici encore la fonction crée une variable locale var distincte de la variable globale var

La fonction dans la proposition 3 modifie bien en place l'objet référencé par la variable globale var. En effet, la fonction accède à la variable var qui d'après la règle LEG est la variable globale. Ensuite, la fonction fait un append sur var, elle modifie donc en place l'objet référencé par la variable globale var. 

La fonction dans la proposition 4 ne modifie pas l'objet référencé. C'est le cas le plus subtile. La fonction déclare la variable var comme globale, donc, dans la fonction, on modifie bien la variable globale var en lui affectant l'objet entier 1, mais on ne modifie pas en place l'objet initialement référencé par var.

La fonction dans la proposition 5 modifie bien en place l'objet référencé. Dans ce cas, l'utilisation de la directive global est inutile. 
[explanation]

<hr/>
Passage d'arguments par défaut
=====

Quelles sont les manières correctes de déclarer un argument var par défaut dans une fonction.

Proposition 1
<pre>
def f(a, b, var == 10):
    print a, b, var
</pre>

Proposition 2
<pre>
def f(a, b, var=10):
    print a, b, var
</pre>

Proposition 3
<pre>
def f(a, var=10, b):
    print a, b, var
</pre>

Proposition 4
<pre>
def f(a, var=10, b=30):
    print a, b, var
</pre>

Proposition 5
<pre>
def f(a, b, var, var=10):
    print a, b, var
</pre>

Choisissez une ou plusieurs propositions.

[ ] Proposition 1
[x] Proposition 2
[ ] Proposition 3
[x] Proposition 4
[ ] Proposition 5

[explanation]
La proposition 1 est syntaxiquement incorrecte. On doit déclarer un argument par défaut avec le signe = et non ==.

La proposition 2 est correcte.

La proposition 3 est incorrecte, les arguments par défaut doivent toujours apparaitre après les arguments ordonnés.

La proposition 4 est correcte puisque dans ce cas, b est également un argument par défaut.

La proposition 5 est incorrecte, on ne peut pas dupliquer un argument dans l'entête d'une fonction, ici var est dupliqué. 
[explanation]

<hr/>
Unpacking des arguments
=====

Comment passer les éléments de la liste suivante
<pre>
L = [1, 2, 'a']
</pre>
comme argument de la fonction
<pre>
def f(a, b, c):
    print a, b, c
</pre>

Proposition 1
<pre>
f(L)
</pre>

Proposition 2
<pre>
f(L[0], L[1], L[2])
</pre>

Proposition 3
<pre>
f(*L)
</pre>

Choisissez une ou plusieurs propositions.

[ ] Proposition 1
[x] Proposition 2
[x] Proposition 3

[explanation]
La proposition 1 est incorrecte parce que L correspond à un seul argument alors que f attend 3 arguments.

La proposition 2 est correcte, mais pas pythonique. On passe en effet trois arguments à f, par contre, on découpe la liste L à la main, ce qui est presque toujours le signe d'une mauvaise utilisation de python. 

La proposition 3 est correcte et pythonique. On utilise la notion de liste unpacking pour automatiquement passer chaque élément de la liste à un argument de la fonction. 
[explanation]
<hr/>
Modules et espaces de nommage 
=====

Dans un fichier spam.py on a 
<pre>
# fichier spam.py
spam = 1
def egg():
    return spam
</pre>

et dans un fichier egg.py on a
<pre>
# fichier egg.py
import spam
egg = 2
def f():
    return spam.egg(), spam.spam, egg
print f()
</pre>

On exécute le fichier egg.py en ligne de commande. Que va imprimer le programme ?

( ) Une exception
( ) La liste [2, 1, 2]
( ) Le tuple (None, 1, 1)
( ) La chaîne de caractère '112'
(x) Le tuple (1, 1, 2)

[explanation]
Le module egg.py import la module spam. La variable spam dans le module egg permet alors d'accéder à l'espace de nommage du module spam. Par conséquent, spam.egg() appelle la fonction egg dans le module spam. Suivant la règle LEG, la variable spam retournée par la fonction egg est la variable spam du module spam.py, donc 1. spam.spam représente la variable spam dans le module spam, et egg est la variable egg dans le module egg. 

Notons que le choix des noms de variables et de modules entraîne volontairement de la confusion pour tester votre compréhension dans ce quiz. Dans un cas réel de programme, on évitera au maximum d'utiliser dans deux modules que l'on écrit des variables avec un nom générique qui ont un rôle différent (entier et fonction pour egg). D'une manière générale, il est souhaitable que le nom du module et de ses attributs soient suffisamment explicites pour comprendre leur rôle sans regarder la documentation (ça n'est évidemment pas le cas ici). 
[explanation]

<hr/>
Processus d'importation d'un module
=====

Comment est-ce que l'interpréteur python trouve la localisation du fichier d'un module sur le disque dur ? Il y a un ou plusieurs choix possibles. 

[x] Dans le répertoire courant, c'est-à-dire le répertoire depuis lequel on a lancé l'interpréteur python. 
[ ] Dans un des répertoires d'installation du système d'exploitation.
[ ] Python trouve automatiquement le fichier quelque soit sa localisation grâce à un mécanisme d'indexation. 
[x] Dans une liste de répertoires contenue dans la variable d'environnement système PYTHONPATH.
[x] Dans les répertoires de la librairie standard. 
[ ] Il faut donner explicitement le chemin complet du fichier lorsque l'on importe un module.
[x] Dans la liste des répertoires contenue dans la variable sys.path qui regroupe tous les chemins de recherche. 

[explanation]
Lorsque l'on importe un module mod, l'interpréteur python cherche en premier le fichier correspondant (mod.py) dans le répertoire courant, puis dans la liste des répertoires contenue dans la variable d'environnement système PYTHONPATH, puis dans les répertoires de la librairie standard. Tous ces chemins sont contenus dans la variable sys.path au démarrage de l'interpréteur. 
[explanation]

<hr/>
Importation et espace de nommage
=====

Supposons que nous avons le code suivant.
Dans un fichier spam.py on a 
<pre>
# fichier spam.py
beans = 1
def f():
    return beans
</pre>

et dans un fichier egg.py on a
<pre>
# fichier egg.py
import spam
from spam import beans
def g(L):
    L.append(spam.beans)
    L.append(beans)
    spam.beans = 2
    L.append(spam.beans)
    L.append(beans)
    L.append(spam.f())
    return L
print g([])
</pre>

On exécute le fichier egg.py en ligne de commande. Qu'imprime le programme ?
( ) [1, 1, 2, 2, 2]
(x) [1, 1, 2, 1, 2]
( ) [1, 1, 2, 2, 1]
( ) [1, 1, 2, 1, 1]

[explanation]
L'instruction "import spam" va importer le module spam et la variable spam va référencer ce module. spam.beans fait donc référence à la variable beans dans l'espace de nommage de spam. Par contre, "from spam import beans" importe le module spam et crée une variable beans dans l'espace de nommage du module egg, qui référence l'objet entier 1. On a donc une référence partagée sur l'entier 1 entre la variable beans dans le module spam et la variable beans dans le module egg. 

spam.beans référence donc l'entier 1, puis beans référence également l'entier 1. L'instruction "spam.beans = 2" change la variable beans dans l'espace de nommage de spam, mais pas dans l'espace de nommage de egg. Donc spam.beans référence maintenant l'entier 2, mais beans référence toujours l'entier 1. Pour finir, spam.f() retourne la variable globale beans dans l'espace de nommage de spam, c'est donc maintenant l'entier 2. 
[explanation]

